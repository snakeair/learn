# JS学习——正则表达式

正则表达式，我们可是一使用*//*表示也可以使用*RegExp*表示。

> 1. 正则对象的方法：将字符串作为参数，比如`regex.test(string)`。
> 2. 字符串对象的方法：将正则对象作为参数，比如`string.match(regex)`。

## 正则对象的属性和方法

### 属性

正则对象有两种属性，一种是查找是否设置修饰符的

> 1. **ignoreCase**：返回一个布尔值，表示是否设置了i修饰符，该属性只读。
> 2. **global**：返回一个布尔值，表示是否设置了g修饰符，该属性只读。
> 3. **multiline**：返回一个布尔值，表示是否设置了m修饰符，该属性只读。

另外一种是：

> 1. `lastIndex`：返回下一次开始搜索的位置。该属性可读写，但是只在设置了`g`修饰符时有意义。
> 2. `source`：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

### 方法

#### test()

验证字符串是否符合正则规则，如果有返回*true*，如果正则中有**g**，则每次都会从上一次结束位置开始向后匹配。另，我们还可以使用`lastIndex`来制定开始搜索的位置：

```javascript
var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false
```

请注意**lastIndex**只对同一个正则有效。

#### exec()

返回匹配结果，如果有匹配则返回一个数组，成员是每个匹配成功的字符串，否则返回`null`

如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的`length`属性等于组匹配的数量再加1。

```javascript
var s = '_x_x';
var r = /_(x)/;

r.exec(s) // ["_x", "x"]
```

另外`exec`返回的数组还包含有两个属性，

> 1. *input*：原始字符串。
> 2. *index*：匹配成功开始的位置

我们可以在结果集之后调用这两个属性来获取我们想要的信息。

使用*exec*匹配的时候会一直匹配下去，直到匹配到最后一个字符，这时候`lastIndex`会返回**0**这表示指针又回到了字符串开始。下次匹配将会重新开始。

同时利用`g`修饰符允许多次匹配的特点，我们可以完成一次全部匹配，同时我们可以手动设置*lastIndex*来匹配的开始位置。

```javascript
var r = /a(b+)a/g;
var s = '_abbba_aba_';

while(true) {
  var match = r.exec(s);
  if (!match) break;
  console.log(match[1]);
}
// bbb
// b
```

## 字符串对象方法

> 1. `match()`：返回一个数组，成员是所有匹配的子字符串。
> 2. `search()`：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
> 3. `replace()`：按照给定的正则表达式进行替换，返回替换后的字符串。
> 4. `split()`：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

`match()`在匹配含有*g*修饰符的时候*lastIndex*是无效的。如果没有匹配到值则会返回**null**。

`search()`会忽略修饰符*g*，如果没有匹配到这回返回**-1**。

`replace()`用于替换，所以它可以接受两个参数，第一个是搜索模式*正则表达式*，第二个是替换的内容。如果使用修饰符*g*的话，原字符串中的所有匹配元素都会被替换掉。另外，我们还可以*使用$来指代所替换的内容*。

> 1. `$&` 指代匹配的子字符串。
> 2. `$` 指代匹配结果前面的文本。
> 3. `$'` 指代匹配结果后面的文本。
> 4. `$n` 指代匹配成功的第`n`组内容，`n`是从1开始的自然数。
> 5. `$$` 指代美元符号`$`。

此外，我们还可以使用函数作为替换的内容，这时候函数的返回值就会替换掉匹配的内容，这个函数可以接受多个参数，第一个表示捕获的到的内容，第二个表示捕获到的组匹配，是三个开始表示捕获到的内容所在的位置，最后一个表示原字符串。

### String.prototype.split()

`split`表示按照正则规则分割字符串，返回一个分割后的的数组。

```javascript
str.split(separator , [limit])
```

两个参数，第一个表示风格规则，第二个表示返回的数组最大成员数*费必须*。

如果正则里面有括号，则括号匹配部分也会作为数组返回。

## 匹配规则

### 字面量字符

`字面量字符`即表达式内容仅表示其字符而不含有其他含义的内容部分，例如：a ,b c等。

### 元字符

字符由特殊含义，不作为字符表示的就是`元字符`。

#### `.`

`.`表示出了回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的所有字符。

#### 位置字符

> 1. `^` 表示字符串的开始位置
> 2. `$` 表示字符串的结束位置

```javascript
// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true
```

#### `|`

竖线符号`|`表示或，`|`可以连续使用，联系使用的时候表示多个字符中的一个。

```javascript
/11|22/.test('911') // true
```

#### 转义符`\`

转义符为反斜杠，表示其后面的字符翻译成为字面量而不是元字符。在正则中需要使用反斜杠的有12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\\`。需要特别注意的是，如果使用`RegExp`方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

### 特殊字符

> 1. `\cX` 表示`Ctrl-[X]`，其中的`X`是A-Z之中任一个英文字母，用来匹配控制字符。
> 2. `[\b]` 匹配退格键(U+0008)，不要与`\b`混淆。
> 3. `\n` 匹配换行键。
> 4. `\r` 匹配回车键。
> 5. `\t` 匹配制表符tab（U+0009）。
> 6. `\v` 匹配垂直制表符（U+000B）。
> 7. `\f` 匹配换页符（U+000C）。
> 8. `\0` 匹配null字符（U+0000）。
> 9. `\xhh` 匹配一个以两位十六进制数（`\x00`-`\xFF`）表示的字符。
> 10. `\uhhhh` 匹配一个以四位十六进制数（`\u0000`-`\uFFFF`）表示的unicode字符。

### 字符类

#### `^`

脱字符，使用在方括号[]内部，且必须是第一个字符，表示除现时内容之外的字符。`注意`脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

```javascript
/[^abc]/.test('hello world') // true
/[^abc]/.test('bbc') // false
```

#### 连字符（-）

某些情况下，对于连续序列的字符，连字符（`-`）用来提供简写形式，表示字符的连续范围。比如，`[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`，同理`[A-Z]`表示26个大写字母。

注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，`[-9]`就表示匹配连字符和`9`，而不是匹配`0`到`9`。

#### 预定义模式

> 1. `\d` 匹配0-9之间的任一数字，相当于`[0-9]`。
> 2. `\D` 匹配所有0-9以外的字符，相当于`[^0-9]`。
> 3. `\w` 匹配任意的字母、数字和下划线，相当于`[A-Za-z0-9_]`。
> 4. `\W` 除所有字母、数字和下划线以外的字符，相当于`[^A-Za-z0-9_]`。
> 5. `\s` 匹配空格（包括制表符、空格符、断行符等），相等于`[\t\r\n\v\f]`。
> 6. `\S` 匹配非空格的字符，相当于`[^\t\r\n\v\f]`。
> 7. `\b` 匹配词的边界。
> 8. `\B` 匹配非词边界，即在词的内部。

#### 重复类

模式的精确匹配次数，使用大括号（`{}`）表示。`{n}`表示恰好重复n次，`{n,}`表示至少重复n次，`{n,m}`表示重复不少于n次，不多于m次。

```javascript
/lo{2}k/.test('look') // true
/lo{2, 5}k/.test('looook') // true
```

#### 量词符

> 1. `?` 问号表示某个模式出现0次或1次，等同于`{0, 1}`。
> 2. `*` 星号表示某个模式出现0次或多次，等同于`{0,}`。
> 3. `+` 加号表示某个模式出现1次或多次，等同于`{1,}`。

#### 贪婪模式

上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。在非贪婪模式下一旦满足条件就不会再匹配下去

> 1. `*?`：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
> 2. `+?`：表示某个模式出现1次或多次，匹配时采用非贪婪模式。

#### 修饰符

##### g

默认情况下，正在在第一次匹配成功后就会停止，加上`g`之后会匹配出所有符合条件的内容。主要用于搜索和替换。

```javascript
var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false
```

##### i

忽略字母大小写。

##### m

多行模式，会修改`^`和`$`的行为。默认情况下`^`和`$`匹配字符串的开始处和结尾处，加上`m`修饰符以后，`^`和`$`还会匹配行首和行尾，即`^`和`$`会识别换行符（`\n`）。

```javascript
/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true
```

#### 组匹配

##### 概述

```javascript
/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true  
```

上面代码中，第一个模式没有括号，结果`+`只表示重复字母`d`，第二个模式有括号，结果`+`就表示匹配“fred”这个词。

```javascript
var m = 'abcabc'.match(/(.)b(.)/g);
m
// ['abc', 'abc']
```

上面代码使用带`g`修饰符的正则表达式，结果`match`方法只捕获了匹配整个表达式的部分。

在正则内部，可以使用`\n`引用括号匹配内容，`n`从1开始的自然数，表示对应顺序的括号。

```javascript
/(.)b(.)\1b\2/.test("abcabc")
// true
```

再解释一下，`\1`表示的是其所在的位置匹配第一个括号内的内容，`\2`表示第二个。实际上`\n`就是代表了其所在位置调用了其所指向的括号的位置。括号的位置为左括号的位置，如果括号有镶套的话，最外层的为第一个，依次递进。

##### 非捕获组

`(?:x)`称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

```javascript
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"]
```

上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。

##### 先行断言

`x(?=y)`称为先行断言（Positive look-ahead），`x`只有在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成`/\d+(?=%)/`。“先行断言”中，括号里的部分是不会返回的。

```javascript
var m = 'abc'.match(/b(?=c)/);
m // ["b"]
```

##### 先行否定断言

`x(?!y)`称为先行否定断言（Negative look-ahead），`x`只有不在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成`/\d+(?!%)/`。

```javascript
/\d+(?!\.)/.exec('3.14')
// ["14"]
```

















































